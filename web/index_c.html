<!DOCTYPE html>
<html>
<head>
    <title>GPUPixel Camera Demo</title>
    <style>
        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }
        #videoElement {
            width: 640px;
            height: 480px;
            background-color: #666;
            margin-bottom: 20px;
        }
        #outputCanvas {
            width: 640px;
            height: 480px;
            background-color: #666;
        }
        .controls {
            margin: 20px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <video id="videoElement" autoplay playsinline></video>
        <canvas id="outputCanvas"></canvas>
        <div class="controls">
            <button id="startButton">Start Camera</button>
            <button id="stopButton">Stop Camera</button>
        </div>
    </div>

    <script src="libgpupixel.js"></script>
    <script>
        let videoElement = document.getElementById('videoElement');
        let canvas = document.getElementById('outputCanvas');
        // let ctx = canvas.getContext('2d');
        let gl = canvas.getContext('webgl2');
        let mediaStream = null;
        let instance = null;
        let context = null;
        let beautyFilter = null;
        let rawData = null;
        var Module = {};

        // 設置canvas尺寸
        // canvas.width = 640;
        // canvas.height = 480;

        // 當WASM模組載入完成
        async function InitModule() {
            console.log('WASM module initialized');

            // const canvas = document.createElement('canvas');
            // const gl = canvas.getContext('webgl2');
            if (!gl) {
                console.error('WebGL2 not available');
                return;
            }

            // console.log('WebGL Version:', gl.getParameter(gl.VERSION));
            // console.log('WebGL Vendor:', gl.getParameter(gl.VENDOR));
            
            try {
                instance  = await GpuPixel({
                    canvas: canvas,
                    // preinitializedWebGLContext: gl,
                    onRuntimeInitialized: () => {
                        console.log('Runtime initialized');
                    },
                    preRun: [() => {
                        console.log('Pre-run stage');
                    }],
                    postRun: [() => {
                        console.log('Post-run stage');
                    }]
                });
                context = new instance.GPUPixelContext();
                const initFunc = () => {
                    rawData = new instance.SourceRawDataInput();

                    // beautyFilter = new instance.BeautyFaceFilter();
                    beautyFilter = instance.BeautyFaceFilter.create();

                    rawData.addTarget(beautyFilter);
                };

                context.runSync(initFunc)

            } catch (e) {
                console.error('Failed to initialize GPUPixel:', e);
            }
        };

        // 啟動相機
        document.getElementById('startButton').onclick = async function() {
            try {
                mediaStream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        width: { ideal: 640 },
                        height: { ideal: 480 }
                    }
                });
                videoElement.srcObject = mediaStream;

                // 等待視頻準備就緒
                await new Promise(resolve => {
                    videoElement.onloadedmetadata = () => {
                        // 設置 canvas 尺寸為視頻實際尺寸
                        canvas.width = videoElement.videoWidth;
                        canvas.height = videoElement.videoHeight;
                        videoElement.play();
                        resolve();
                    };
                });
                
                // 開始處理影像
                requestAnimationFrame(processFrame);
                // processFrame();
            } catch (e) {
                console.error('Error accessing camera:', e);
            }
        };

        // 停止相機
        document.getElementById('stopButton').onclick = function() {
            if (mediaStream) {
                mediaStream.getTracks().forEach(track => track.stop());
                videoElement.srcObject = null;
            }
        };

        // 處理每一幀
        function processFrame() {
            if (!videoElement.srcObject) {
                requestAnimationFrame(processFrame);
                return;
            }
            
            if (videoElement.readyState !== videoElement.HAVE_ENOUGH_DATA) {
                requestAnimationFrame(processFrame);
                return;
            }
            
            try {
                // 1. 創建並綁定紋理
                const videoTexture = gl.createTexture();
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, videoTexture);
                
                // 設置紋理參數
                gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);  // 翻轉 Y 軸
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                
                // 上傳視頻幀到紋理
                gl.texImage2D(
                    gl.TEXTURE_2D,    // target
                    0,                // level
                    gl.RGBA,          // internalformat
                    gl.RGBA,          // format
                    gl.UNSIGNED_BYTE, // type
                    videoElement      // pixel source
                );

                // 檢查 WebGL 錯誤
                const glError = gl.getError();
                if (glError !== gl.NO_ERROR) {
                    console.error('WebGL error:', glError);
                    requestAnimationFrame(processFrame);
                    return;
                }

                console.log(videoTexture);

                // 2. 調用 GPUPixel filter 處理
                // rawData.uploadRGBBytes(
                //     videoTexture, 
                //     videoElement.videoWidth, 
                //     videoElement.videoHeight, 
                //     videoElement.videoWidth * 4,
                //     Date.now()  // 添加時間戳
                // );
                
                // 3. 請求下一幀
                requestAnimationFrame(processFrame);
                
            } catch (error) {
                console.error('處理幀時出錯:', error);
                requestAnimationFrame(processFrame);
            }
        }

        InitModule();
    </script>
</body>
</html>
